<strong><span style="color:#333333;font-size:18px;">1．最佳置换（OPT）算法</span></strong><br />
在预知一个进程的页面号引用串的情况下，<strong><u>每</u></strong><strong><u>次都淘汰以后不再使用的或以后最迟再被使用的页面，这种算法就是最佳置换算法。</u></strong> 
<p>
	<strong><span style="color:#333333;font-size:18px;">2．先进先出（FIFO）算法</span></strong><br />
FIFO算法是最简单的页面置换算法，<u><strong>每次总是</strong></u><u><strong>淘汰最先进入内存的页面</strong></u>，也就是淘汰在内存驻留时间最长的页面。
</p>
<p>
	<strong><span style="color:#333333;font-size:18px;">3．最近最少使用（LRU）算法</span></strong><br />
<strong><u>选择最近最长时间没有被使用的页面予以淘汰</u>，</strong>其思想是用以前的页面引用情况来预测将来会出现的页面引用情况，也就是假设一个页面刚被访问，那么不久该页面还会被访问。即最佳置换算法是“向后看”，而LRU算法则是“向前看”。
</p>
<p>
	<strong><span style="color:#333333;font-size:18px;">4．时钟置换（CLOCK）算法</span></strong><br />
时钟置换（CLOCK）算法也称为最近未使用算法（NRU），是LRU和FIFO的折中。作为LRU的近似算法，CLOCK算法给每个页面设置一个访问位，用以标识该页最近有没有被访问过。CLOCK维护一个内存中所有页面的循环链表，当程序需要访问链表中存在的页面时，该页面的访问位就被置位为1；否则，若程序要访问的页面没有在链表中，那就需要淘汰一个内存中的页面，<u><strong>于是一个</strong></u><u><strong>指针就从上次被淘汰页面的下一个位置开始顺序地去遍历这个循环链表，当这个指针指向的页面的访问位为1时，就把该访问位清零，指针再向下移动，当指针指向的页面的访问位为0时，就选择淘汰掉这一页面，若遍历了一遍链表仍没找到可以淘汰的页面，那么就继续遍历下去。</strong></u> 
</p>
<p>
	<strong>改进型CLOCK算法</strong>，它<span style="color:#E53333;"><u><strong>考虑了页面载入内存后是否被修改的问题，增加了修改位</strong></u></span>。在访问位同为0的进程间优先淘汰没有修改过的页面，因为没有修改过的页面可以被直接淘汰掉，而修改过的页面需要写回到外存中。与简单CLOCK算法相比，该算法可减少磁盘I/O次数，但会增加扫描次数。
</p>
<p>
	<strong><span style="color:#333333;font-size:18px;">5．其他页面置换算法</span></strong><br />
<strong>a. 最不常用置换（LFU）算法：</strong>选择到当前时间为止访问次数最少的页面淘汰。该算法要求为每页设置一个访问计数器，每当页面被访问时，该页的访问计数器加1。发生缺页中断时，淘汰计数值最小的页面，并将所有计数器清零。
</p>
<p>
	<strong>b. 页面缓冲（PBA）算法：</strong>PBA算法是对FIFO算法的发展，通过建立置换页面的缓冲，找回刚被置换的页面，从而减少系统I/O的消耗。
</p>