<p style="font-size:16px;">
	<strong><span style="font-size:24px;">顺序查找</span></strong>
</p>
<p style="font-size:16px;">
	（1）<span style="color:#E53333;">顺序查找的优点：</span>算法简单，且对表的结构无任何要求，无论是用向量还是用链表来存放节点，也无论节点之间是否按关键字有序，它都同样适用。
</p>
<p style="font-size:16px;">
	（2）<span style="color:#E53333;">顺序查找的缺点：</span>查找效率低，因此，当n较大时不宜采用顺序查找。
</p>
<p style="font-size:16px;">
	（3）等概率情况下平均查找长度ASL=(n+1)/2，查找不成功的平均查找长度为n。
</p>
<p style="font-size:16px;">
	<strong><span style="font-size:24px;">分块查找</span></strong>
</p>
<p style="font-size:16px;">
	<span style="color:#E53333;background-color:#FFFFFF;">分块查找首先查找索引表</span><span style="color:#E53333;">。</span>因为索引表是有序表，所以我们可以采用二分查找或顺序查找，以确定待查找的节点在哪一块。一般来说，如果题目中没有给定是什么查找方式，默认采用顺序查找。然后，在已确定的块中进行顺序查找。这是因为在快中的数据是无序的。<span style="line-height:1.5;color:#E53333;">分块查找是两次查找过程</span><span style="line-height:1.5;">。整个查找过程的平均查找长度是两次平均查找长度之和。</span>
</p>
<p style="font-size:16px;">
	<strong><span style="font-size:24px;">折半查找</span></strong>
</p>
<p style="font-size:16px;">
	<span style="line-height:1.5;">折半查找的平均查找长度如下：</span>
</p>
<p style="font-size:16px;">
	（1）<span style="color:#E53333;">查找成功时的平均查找长度：</span>设内部节点的总数为n=2<sup>h</sup>-1，则判定树是深度为h=log<sub>2</sub>(n+1)的满二叉树（深度h不计外部节点）。树中第k层上的节点个数为2<sup>k-1</sup>,查找它们所需的比较次数为k，因此在等概率假设下，二分查找成功时的平均查找长度为：ASL<sub>bn</sub>=log<sub>2</sub>(n+1)-1。
</p>
<p style="font-size:16px;">
	（2）<span style="color:#E53333;font-size:16px;line-height:24px;">查找失败时的平均查找长度：</span>二分查找在查找失败时所需比较的关键字个数不超过判定树的深度，在最坏的情况下查找成功的比较次数也不超过判定树的深度，即为：[log<sub>2</sub>(n+1)]。
</p>
<p style="font-size:16px;">
	<span style="color:#E53333;">二分查找的最坏性能和平均性能相当接近。</span>
</p>
<p style="font-size:16px;">
	<strong><span style="font-size:24px;">B-树</span></strong>
</p>
<p style="font-size:16px;">
	（1）B-树中节点的<span style="color:#E53333;">关键字的个数要比节点的儿子数少1</span>，一定不能将两者混淆。比如，除根之外的所有非终端节点至少有[m/2]棵子树，则说明除根之外的所有非终端节点至少有[m/2]-1个关键字。
</p>
<p style="font-size:16px;">
	（2）B-树最重要的特征就是平衡性，<span style="color:#E53333;">通常被用来设计磁盘的访问策略</span>。
</p>
<p style="font-size:16px;">
	<strong><span style="font-size:24px;">哈希表</span></strong>
</p>
<p style="font-size:16px;">
	（1）设m和n分别表示表长和表中填入的节点数，则将a=n/m定义为散列表的装填因子（Load Factor）。a越大，表越满冲突的机会也越大。通常取a&lt;=1。
</p>
<p style="font-size:16px;">
	（2）散列表解决冲突的方法通常有开放定址法和链地址法。<span style="color:#E53333;">链地址法会消耗额外的存储空间</span>，如果把这些额外的空间用来加长散列表，会减小装填因子，从而加快查找速度。但是<span style="color:#E53333;">开放定址法对哈希表的删除操作支持不好</span>。
</p>
<p style="font-size:16px;">
	（3）散列表的平均查找长度不是结点个数n的函数，而是装填因子a的函数。因此<span style="color:#E53333;">在设计散列表时可选择a以控制散列表的平均查找长度。</span>
</p>