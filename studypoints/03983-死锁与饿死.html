<p>
	<span style="line-height:1.5;font-size:18px;"><strong>1. 进程饿死的概念</strong></span> 
</p>
<p>
	<span style="line-height:1.5;">由于分配不到资源使某一进程长期处于等待，并且等待时间给进程推进和响应带来明显影响时，则称此时发生了</span><strong>进程饥饿</strong><span style="line-height:1.5;">，当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时，称该</span><strong>进程被饿死</strong><span style="line-height:1.5;">。</span> 
</p>
<p>
	<strong><span style="font-size:18px;color:#333333;">2. 饿死与死锁的关系</span></strong> 
</p>
<p>
	<strong><span style="color:#E53333;">饿死与死锁有一定联系：二者都是由于竞争资源而引起的，但又有明显差别</span></strong>，主要表现在如下几个方面。
</p>
<p>
	<b>a.&nbsp;</b>从进程状态考虑，死锁进程都处于等待状态；忙时等待（处于运行或就绪状态）的进程并非处于等待状态，但却可能被饿死；
</p>
<p>
	<b>b.&nbsp;</b>死锁进程等待的是永远不会被释放的资源；而饿死进程等待的是会被释放但却不会分配给自己的资源，表现为等待时间没有上界（排队等待或忙时等待）；
</p>
<p>
	<b>c.&nbsp;</b>死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死；
</p>
<p>
	<b>d.&nbsp;</b>死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。
</p>
<span style="color:#E53333;"><u>饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死，以确保所有进程不被忽视，如多级反馈队列调度算法。</u></span><br />
<div>
	<br />
</div>