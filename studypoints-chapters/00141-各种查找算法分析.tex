\textbf{{顺序查找}}

（1）{顺序查找的优点：}算法简单，且对表的结构无任何要求，无论是用向量还是用链表来存放节点，也无论节点之间是否按关键字有序，它都同样适用。

（2）{顺序查找的缺点：}查找效率低，因此，当n较大时不宜采用顺序查找。

（3）等概率情况下平均查找长度ASL=(n+1)/2，查找不成功的平均查找长度为n。

\textbf{{分块查找}}

{分块查找首先查找索引表}{。}因为索引表是有序表，所以我们可以采用二分查找或顺序查找，以确定待查找的节点在哪一块。一般来说，如果题目中没有给定是什么查找方式，默认采用顺序查找。然后，在已确定的块中进行顺序查找。这是因为在快中的数据是无序的。{分块查找是两次查找过程}{。整个查找过程的平均查找长度是两次平均查找长度之和。}

\textbf{{折半查找}}

{折半查找的平均查找长度如下：}

（1）{查找成功时的平均查找长度：}设内部节点的总数为n=2\textsuperscript{h}-1，则判定树是深度为h=log\textsubscript{2}(n+1)的满二叉树（深度h不计外部节点）。树中第k层上的节点个数为2\textsuperscript{k-1},查找它们所需的比较次数为k，因此在等概率假设下，二分查找成功时的平均查找长度为：ASL\textsubscript{bn}=log\textsubscript{2}(n+1)-1。

（2）{查找失败时的平均查找长度：}二分查找在查找失败时所需比较的关键字个数不超过判定树的深度，在最坏的情况下查找成功的比较次数也不超过判定树的深度，即为：{[}log\textsubscript{2}(n+1){]}。

{二分查找的最坏性能和平均性能相当接近。}

\textbf{{B-树}}

（1）B-树中节点的{关键字的个数要比节点的儿子数少1}，一定不能将两者混淆。比如，除根之外的所有非终端节点至少有{[}m/2{]}棵子树，则说明除根之外的所有非终端节点至少有{[}m/2{]}-1个关键字。

（2）B-树最重要的特征就是平衡性，{通常被用来设计磁盘的访问策略}。

\textbf{{哈希表}}

（1）设m和n分别表示表长和表中填入的节点数，则将a=n/m定义为散列表的装填因子（Load
Factor）。a越大，表越满冲突的机会也越大。通常取a\textless{}=1。

（2）散列表解决冲突的方法通常有开放定址法和链地址法。{链地址法会消耗额外的存储空间}，如果把这些额外的空间用来加长散列表，会减小装填因子，从而加快查找速度。但是{开放定址法对哈希表的删除操作支持不好}。

（3）散列表的平均查找长度不是结点个数n的函数，而是装填因子a的函数。因此{在设计散列表时可选择a以控制散列表的平均查找长度。}
